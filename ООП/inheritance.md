# Наследование

> Принцип ООП, где мы можем унаследовать, переопределять и использовать все аттррибуты и методы родительского класса

```py
class A:
    def method(self):
        print("Метод в классе А")

obj_a = A()
obj_a.method()     #Метод в классе А

class B(A):
    pass

obj_b = B()
obj_b.method()      #Метод в классе A

```
> класс А -это родительский

> класс В -это дочернийе

## Переопедиление 

> Когда мы создаем метод или фттрибут с таким же названием как и в родительских классах

```py
class C(A):
    def method(self):
        print("Метод в классе С")

obj_c = C()
obj_c.method()     #Метод в классе С
```

## Виды наследования

* **Одинночное** (когда один родитель)
* **Множественное** (когда несколько родителей)
* **Многоуровневое** (когда у родителей есть родитель)
* **Иерархическое** (когда у каждого есть только один родитель, но у родителя может много детей)
* **Гибридное** (совмещение разных видов наследования)

## Проблемы множественного наследования
1. Проблема ромба (решена с помощью MRO(с версии 2.6))
> MRO - method resolution order (строит порядок для поиска отребутов)

```py
class A: 
    pass
class B:
    pass
class C(A,B):
    pass

# до mro
[C, A, object, C, B, object]

# после mro
[C, A, B, object]
```

2. Проблема перекресного наследования (не решенная, возникает когда невозможно построить приоритет родителей)

```py
class A: 
    pass
class B:
    pass
class C(A,B):
    pass
class D(B,A):
    pass
class E(C,D):
    pass

#TypeError: Cannot create a consistent method resolution
# order (MRO) for bases A, B
```